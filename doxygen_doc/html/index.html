<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: EigenValue Solver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">EigenValue Solver </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">Introduction</a></li>
<li class="level1"><a href="#solvers">Solvers</a><ul><li class="level2"><a href="#general_power_method">Power Method and Variants</a><ul><li class="level3"><a href="#power_method">Power Method</a></li>
<li class="level3"><a href="#shifted_power_method">Shifted Power Method</a></li>
<li class="level3"><a href="#inverse_power_method">Inverse Power Method</a></li>
<li class="level3"><a href="#shifted_inverse_power_method">Shifted Inverse Power Method</a></li>
</ul>
</li>
<li class="level2"><a href="#qr_method">QR Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p >This code aims at solving eigenvalue problems of the form <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$Ax=\lambda x$" src="form_0.png"/></picture>, where <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A\in \mathbb{C}^{n\times n}$" src="form_1.png"/></picture>, <picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$x \in \mathbb{C}^n$" src="form_2.png"/></picture> and <picture><source srcset="form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\lambda \in \mathbb{C}$" src="form_3.png"/></picture> (The vector space can also be <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathbb{Z}$" src="form_4.png"/></picture> or <picture><source srcset="form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\mathbb{R}$" src="form_5.png"/></picture>).</p>
<p >The code uses the following libraries:</p><ul>
<li>Eigen 3.4.0 (<a href="https://eigen.tuxfamily.org/index.php?title=Main_Page">Link</a>).</li>
<li>GoogleTest 1.11.0 (<a href="https://github.com/google/googletest">Link</a>).</li>
</ul>
<p >5 classes have been implemented to solve this problem in 4 different algorithms:</p><ul>
<li><a class="el" href="class_power_method.html">PowerMethod</a>: Solves the eigenvalue problem using the standard power method (see section <a class="el" href="index.html#power_method">Power Method</a>).</li>
<li>ShiftedPowerMethod: Solves the eigenvalue problem using the shifted power method (see section <a class="el" href="index.html#shifted_power_method">Shifted Power Method</a>).</li>
<li><a class="el" href="class_inverse_power_method.html">InversePowerMethod</a>: Solves the eigenvalue problem using the inverse power method (see section <a class="el" href="index.html#inverse_power_method">Inverse Power Method</a>).</li>
<li>ShiftedInversePowerMethod: Solves the eigenvalue problem using the shifted inverse power method (see section <a class="el" href="index.html#shifted_inverse_power_method">Shifted Inverse Power Method</a>).</li>
<li><a class="el" href="class_q_r_method.html">QRMethod</a>: Solves the eigenvalue problem using the QR method (see section <a class="el" href="index.html#qr_method">QR Method</a>).</li>
</ul>
<p >More details can be found on the algorithms used in the detailed description of the classes.</p>
<hr  />
<h1><a class="anchor" id="solvers"></a>
Solvers</h1>
<p >An abstraction of an eigenvalue solver is implemented under the GeneralEigenSolver class. All solvers inherit (directly or indirectly) from this class. This class is templated such that any type of scalar can be used, as long as Eigen::Matrix&lt;ScalarType,-1,-1&gt; can be called.</p>
<p >Two attributes are initialized with this class:</p><ul>
<li>The maximum number of iterations.</li>
<li>The matrix <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A$" src="form_6.png"/></picture> from which we wish to extract the eigenvalues.</li>
</ul>
<p >Then 2 types of daughter classes inherit from GeneralEigenSolver:</p><ul>
<li>GeneralPowerMethod for the power methods and its variants (see the next section <a class="el" href="index.html#general_power_method">Power Method and Variants</a>).</li>
<li><a class="el" href="class_q_r_method.html">QRMethod</a> (see section <a class="el" href="index.html#qr_method">QR Method</a>).</li>
</ul>
<hr  />
<h2><a class="anchor" id="general_power_method"></a>
Power Method and Variants</h2>
<p >An abstraction of a solver using the power method is implemented under the GeneralPowerMethod class. All variants of the power method inherit from this class.</p>
<p >Two attributes are initialized with this class:</p><ul>
<li>The threshold for the power method. (GeneralPowerMethod::mThreshold)</li>
<li>The starting vector for the power method. After solving, this variable becomes the corresponding eigenvector. (GeneralPowerMethod::mEigenVector)</li>
</ul>
<p >Two methods are also implemented in this class:</p><ul>
<li>GeneralPowerMethod::solve(MatrixType&lt;ScalarType&gt;&amp; A) which solves an eigenvalue problem using the power method.</li>
<li>GeneralPowerMethod::initRandomEigenVector() which randomly initialize the starting vector.</li>
</ul>
<p >The variants then use solve(MatrixType&lt;ScalarType&gt;&amp; A) with different matrices depending on the desired algorithm.</p>
<p >Then 4 daughter classes inherit from GeneralPowerMethod:</p><ul>
<li><a class="el" href="class_power_method.html">PowerMethod</a>, the standard power method. Computes the highest eigenvalue, in absolute value (see section <a class="el" href="index.html#power_method">Power Method</a>).</li>
<li>ShiftedPowerMethod, the shifted power method. (see <a class="el" href="index.html#shifted_power_method">Shifted Power Method</a>).</li>
<li><a class="el" href="class_inverse_power_method.html">InversePowerMethod</a>. Computes the smallest eigenvalue, in absolute value (see section <a class="el" href="index.html#inverse_power_method">Inverse Power Method</a>).</li>
<li>ShiftedInversePowerMethod. Computes the closest eigenvalue to some shift <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\sigma$" src="form_7.png"/></picture> (see section <a class="el" href="index.html#shifted_inverse_power_method">Shifted Inverse Power Method</a>).</li>
</ul>
<hr  />
<h3><a class="anchor" id="power_method"></a>
Power Method</h3>
<p >The <a class="el" href="class_power_method.html">PowerMethod</a> class implements the standard power method. Given a matrix <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A \in \mathbb{C}^{n\times n}$" src="form_8.png"/></picture> with eigenvalues <picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$|\lambda_1| \ge |\lambda_2| \ge \cdots \ge |\lambda_n|$" src="form_9.png"/></picture>, then the returned eigenvalue is <picture><source srcset="form_10_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\lambda_1$" src="form_10.png"/></picture>. This will not be the case if the starting vector is in the null space of <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A$" src="form_6.png"/></picture> or an eigenvector of <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A$" src="form_6.png"/></picture>.</p>
<ul>
<li></li>
</ul>
<h3><a class="anchor" id="shifted_power_method"></a>
Shifted Power Method</h3>
<p >The ShiftedPowerMethod class implements the shifted power method. Given a matrix <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A \in \mathbb{C}^{n\times n}$" src="form_8.png"/></picture> with eigenvalues <picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$|\lambda_1| \ge |\lambda_2| \ge \cdots \ge |\lambda_n|$" src="form_9.png"/></picture>, then the returned eigenvalue is <picture><source srcset="form_11_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\lambda_i$" src="form_11.png"/></picture> such that <picture><source srcset="form_12_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$|\lambda_i - \sigma $" src="form_12.png"/></picture> is maximal. This will not be the case if the starting vector is in the null space of <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A$" src="form_6.png"/></picture> or an eigenvector of <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A$" src="form_6.png"/></picture>.</p>
<hr  />
<h3><a class="anchor" id="inverse_power_method"></a>
Inverse Power Method</h3>
<p >The <a class="el" href="class_inverse_power_method.html">InversePowerMethod</a> class implements the inverse power method algorithm. Given a matrix <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A \in \mathbb{C}^{n\times n}$" src="form_8.png"/></picture> with eigenvalues <picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$|\lambda_1| \ge |\lambda_2| \ge \cdots \ge |\lambda_n|$" src="form_9.png"/></picture>, then the returned eigenvalue is <picture><source srcset="form_13_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$\lambda_n$" src="form_13.png"/></picture>. This will not be the case if the starting vector is in the null space of <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A$" src="form_6.png"/></picture> or an eigenvector of <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A$" src="form_6.png"/></picture>.</p>
<p >This class assumes that <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A$" src="form_6.png"/></picture> is invertible.</p>
<hr  />
<h3><a class="anchor" id="shifted_inverse_power_method"></a>
Shifted Inverse Power Method</h3>
<p >The ShiftedInversePowerMethod class implements the inverse power method algorithm. Given a matrix <picture><source srcset="form_8_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A \in \mathbb{C}^{n\times n}$" src="form_8.png"/></picture> with eigenvalues <picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$|\lambda_1| \ge |\lambda_2| \ge \cdots \ge |\lambda_n|$" src="form_9.png"/></picture>, then the returned eigenvalue is the one closest to some shift (ShiftedInversePowerMethod::mShift). This will not be the case if the starting vector is in the null space of <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A$" src="form_6.png"/></picture> or an eigenvector of <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A$" src="form_6.png"/></picture>.</p>
<p >Here, the shift parameter, ShiftedInversePowerMethod::mShift, must be initialized before calling ShiftedInversePowerMethod::solve().</p>
<hr  />
<h2><a class="anchor" id="qr_method"></a>
QR Method</h2>
<p >The <a class="el" href="class_q_r_method.html">QRMethod</a> class implements a solver using the QR method. In order for the algorithm to retrieve the correct eigenvalues, the matrix <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$A$" src="form_6.png"/></picture> must real and not complex.</p>
<p >The QRMethod::solveAll() method returns a Eigen::Vector&lt;ScalarType&gt; containing the eigenvalues in descending order. It is also possible to retrieve specific eigenvalues using QRMethod::solve(int n) and QRMethod::solve(). The former will retrieve the n-th largest eigenvalue while the latter the largest one.</p>
<p >Here, special care should be taken in choosing the GeneralEigenSolver::mMaxIter attribute, as the algorithm <b>will</b> iterate this number of times. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
